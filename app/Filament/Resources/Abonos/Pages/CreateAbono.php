<?php

namespace App\Filament\Resources\Abonos\Pages;

use Log;
use App\Filament\Resources\Abonos\AbonoResource;
use App\Models\Purchase;
use Filament\Actions;
use Filament\Notifications\Notification;
use Filament\Resources\Pages\CreateRecord;
use Illuminate\Contracts\Support\Htmlable;

class CreateAbono extends CreateRecord
{
    protected static string $resource = AbonoResource::class;

    public function canCreateAnother(): bool
    {
        return false;
    }
    protected function getRedirectUrl(): string
    {
        return $this->getResource()::getUrl('index');
    }
    public function getTitle(): string|Htmlable
    {
        return 'Nuevo Abono a cuenta por pagar';// TODO: Change the autogenerated stub
    }
    protected function afterCreate(): void
    {
        $abono = $this->record;
        $data = $this->data;

        if (!empty($data['purchases']) && is_array($data['purchases'])) {
            $syncData = [];

            foreach ($data['purchases'] as $purchaseData) {
                if (!empty($purchaseData['purchase_id']) && !empty($purchaseData['monto_pagado'])) {
                    $purchase = Purchase::find($purchaseData['purchase_id']);

                    // Calcular saldos (ejemplo simplificado)
                    $totalAbonosAntes = $purchase->abonos()
                        ->where('abono_id', '!=', $abono->id)
                        ->sum('abono_purchase.monto_pagado');

                    $saldoAnterior = max(0, $purchase->purchase_total - $totalAbonosAntes);

                    $totalAbonosActual = $totalAbonosAntes + $purchaseData['monto_pagado'];
                    $saldoActual = max(0, $purchase->purchase_total - $totalAbonosActual);

                    $syncData[$purchase->id] = [
                        'monto_pagado' => $purchaseData['monto_pagado'],
                        'saldo_anterior' => $saldoAnterior,
                        'saldo_actual' => $saldoActual,
                    ];
                }
            }

            if (!empty($syncData)) {
                $abono->purchases()->sync($syncData);
                // Recarga la relación antes de actualizar saldos
                $abono->load('purchases');
                $abono->actualizarSaldos();
            }
        }
    }


    protected function mutateFormDataBeforeCreate(array $data): array
    {
        Log::info('Abono: mutateFormDataBeforeCreate', [
            'data' => $data,
        ]);
        return parent::mutateFormDataBeforeCreate($data);
    }

    public function beforeCreate(): void
    {
        $data = $this->data;
        $purchases = $data['purchases'] ?? [];

        $totalAbonos = collect($purchases)->sum('monto_pagado');

        if (empty($purchases)) {
            $this->notifyError('Debe seleccionar al menos una factura para aplicar el abono.');
            return;
        }

        if ($totalAbonos <= 0) {
            $this->notifyError('Debe ingresar al menos un monto pagado mayor a cero para alguna factura.');
            return;
        }

        $allPositive = collect($purchases)->every(fn($p) => isset($p['monto_pagado']) && $p['monto_pagado'] > 0);
        if (!$allPositive) {
            $this->notifyError('Todos los montos pagados deben ser mayores a cero.');
            return;
        }

        if ($totalAbonos > $data['monto']) {
            $this->notifyError('La suma de abonos por factura no puede ser mayor al monto total del abono.');
            return;
        }

        if ($totalAbonos < $data['monto']) {
            $this->notifyError('La suma de abonos por factura debe ser igual al monto total del abono.');
            return;
        }
    }

// Método auxiliar para evitar repetición
    protected function notifyError(string $message): void
    {
        Notification::make()
            ->title($message)
            ->danger()
            ->send();
        $this->halt();
    }


}
